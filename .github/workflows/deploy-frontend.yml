name: Deploy Frontend and Update API Gateway

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # For AWS OIDC
      contents: read # To checkout code

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1
        # role-to-assume: arn:aws:iam::ACCOUNT-ID:role/GitHubActionRole # OIDC Recommended
        # role-session-name: FrontendDeploySession

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3

    - name: Terraform Init
      working-directory: infra
      run: terraform init

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0' # Match your EKS version

    - name: Update kubeconfig for EKS
      run: aws eks update-kubeconfig --region us-east-1 --name eks1

    # --- Docker Build and Push Step ---
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push FRONTEND multi-platform Docker image
      uses: docker/build-push-action@v6
      with:
        context: ./frontend # Set context to frontend directory
        file: ./frontend/Dockerfile # Assumes Dockerfile is directly in frontend/
        platforms: linux/amd64,linux/arm64
        push: true
        tags: abhishekt/quantum-hub-frontend:latest # Use the specific tag from your manifest

    # --- End Docker Step ---

    # Note: Skipping backend secret creation assuming frontend doesn't need it directly

    - name: Deploy Kubernetes Manifests
      run: |
        echo "Applying Backend/Ingress Manifest (to update Ingress rules)..."
        # Apply this first to ensure Ingress rules are updated before frontend potentially routes traffic
        kubectl apply -f k8s/quantum-microservice-k8s-deployment.yaml

        echo "Applying Frontend Manifest (Deployment and Service)..."
        kubectl apply -f k8s/frontend-app-k8s.yaml

    - name: Wait for Frontend Deployment Rollout
      run: kubectl rollout status deployment frontend-app-deployment -n default --timeout=5m

    - name: Wait for Ingress and Get ALB DNS Name
      id: get_alb_dns
      run: |
        echo "Waiting for ALB Ingress to provision/update..."
        count=0
        ALB_DNS_NAME=""
        while [ -z "$ALB_DNS_NAME" ] && [ $count -lt 15 ]; do
          ALB_DNS_NAME=$(kubectl get ingress quantum-microservice-ingress -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
          if [ -z "$ALB_DNS_NAME" ]; then
            echo "ALB DNS name not available yet, waiting 20 seconds... (Attempt $((count+1))/15)"
            sleep 20
            count=$((count+1))
          else
            # Add a small delay even after finding the DNS name to allow rules to propagate
            echo "ALB DNS found: ${ALB_DNS_NAME}. Waiting 10s for rules to settle..."
            sleep 10
          fi
        done

        if [ -z "$ALB_DNS_NAME" ]; then
          echo "Error: Timed out waiting for ALB DNS name after $count attempts."
          kubectl get ingress quantum-microservice-ingress -n default -o yaml # Print ingress details for debugging
          exit 1
        fi

        echo "Using ALB DNS Name: ${ALB_DNS_NAME}"
        echo "ALB_DNS_NAME=${ALB_DNS_NAME}" >> $GITHUB_ENV
        echo "alb_hostname=${ALB_DNS_NAME}" >> $GITHUB_OUTPUT

    - name: Apply Terraform (API Gateway Routes)
      id: tf_apply
      working-directory: infra
      run: |
        echo "Applying Terraform changes for API Gateway routes..."
        # This apply uses the api_gateway.tf with the two routes
        terraform apply -var="alb_dns_name=${{ env.ALB_DNS_NAME }}" -auto-approve
        echo "invoke_url=$(terraform output -raw api_gateway_invoke_url)" >> $GITHUB_OUTPUT

    - name: Test API Gateway Endpoints
      run: |
        API_URL="${{ steps.tf_apply.outputs.invoke_url }}"
        echo "Testing API Gateway Health endpoint (Backend - /api/v1/health)..."
        curl -sf "${API_URL}/api/v1/health" || (echo "Backend health check FAILED"; exit 1)
        echo "Backend health check successful!"

        echo "Testing API Gateway Root endpoint (Frontend - /)..."
        curl -sf -o /dev/null -w "%{http_code}" "${API_URL}/" | grep -E '^[23]' || (echo "Frontend root test FAILED"; exit 1)
        echo "Frontend root test successful!"
